import numpy as np

# Defining constants used for hashing and binning
LargestPrime = 21503#2147483869
bucket_prime = 27#2147483869
bands = 27
rows = 27
n = bands * rows
var = np.random.uniform(0, 1000,n)
cons = np.random.uniform(0, 1000,n)
var_lsh = np.random.uniform(0,100,rows)
cons_lsh = np.random.uniform(0,100,rows)


# Hashing function for min hash
def minHash_func(x, var, cons, n):
    return (var * x + cons) % n

# Randomly sample coefficients from uniform distribution for hash functions in min hashing
#random.seed(0)
#def generate_hash_coefficients(n):
#    hash_funcs = []

#    for i in xrange(n):
#        var = np.random.uniform(0, 1000)
#        cons = np.random.uniform(0, 1000)
#        hash_funcs.append([var, cons])
#    return hash_funcs


# Define the number of hash functions for min hashing. Default n = 10.
# Signature generated by min-hashing. Default length 10
def get_minHash_signatures(shingle, n = 10):
    #hash_coefficients = generate_hash_coefficients(n)

    signature = []
    # Looping through all the hash coefficients
    #for coeff in hash_coefficients:
    for j in range(n):

        minHashVal = LargestPrime
        # Looping to find the smallest hash value
        for i in shingle:
            val = minHash_func(i, var[j], cons[j] , LargestPrime)

            if val < minHashVal:
                minHashVal = val

        signature.append(minHashVal)

    #for i in range(len(shingle)):
    #    for j in xrange(n):
    #            h_j = hash_value[j]
    #            signature[j] = min(signature[j], h_j[i])

    return signature


# Function to map the rows of the docID to the bucket
# Hashing function uses a bucket_prime number with default = 251
def map_sig_to_LSH_buckets(docID, signature, nbands = 5, nrows = 2, bucket_prime = 251):
    if nbands * nrows != len(signature):
        raise 'Choice of bands and rows does not match length of signature! ' \
              'Choose bands and rows correctly. '

    buckets_array = []

    i = 0
    for b in range(nbands):
        current_band = signature[i:i + nrows]
        #key = int(sum(current_band) % bucket_prime)
        #key = int(sum(current_band))
        key = sum([(minHash_func(current_band[j],var_lsh[j],cons_lsh[j],nrows)) for j in range(len(current_band))])
        #print key
        buckets_array.append((str(key), docID))
        i = i + nrows

    return buckets_array

# Define mapper function
# Given an empty key and value (input string) the function returns all LSH keys for that page
def mapper( key, value):
    (docID, shingles) = value.split(None, 1)
    sig = get_minHash_signatures(map(int, shingles.split(' ')), n)
    for i in map_sig_to_LSH_buckets(docID,sig, bands, rows, bucket_prime):
        yield i


# For a given key (bucket number) and values (set of all documents with the same hash key) return all possible pairs of similar documents
def reducer(key, values):
    pages = sorted(map(lambda x: int(x.split("_")[1]), values))
    for i in xrange(len(pages) - 1):
        for j in xrange(i + 1, len(pages)):
            if pages[i] < pages[j]:
                yield pages[i], pages[j]